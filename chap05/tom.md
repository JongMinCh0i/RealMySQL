# 트랜잭션과 잠금

# Intro

- 트랜잭션은 작업의 완전성을 보장
    - 논리적인 작업 셋을 완벽하게 처리하거나 처리하지 못할 경우에는 원상태로 복구 → 작업의 일부만 적용되는 현상(**Partial update**)이 발생하지 않게 보장 한다.
    - Transaction 의 ACID 특성 중 **Atomic, All or Nothing** 해당됨
- 잠금과 트랜잭션의 차이점
    - Locking은 **동시성**을 제어하기 위한 기능
        - 여러 커넥션에서 동시에 동일 자원에 대한 요청시 **At the same time** 에 하나의 데이터만 처리된다.
        - 멀티 쓰레딩 상황에서 동시성 제어를 위한 **Critical Section(임계영역**)을 **Locking** 을 활용하여 구현 한다.
    - 트랜잭션은 **데이터 정합성**을 보장하기 위한 기능
        - 격리 수준이라는 것은 하나, 여러 트랜잭션 간 작업 내용을 어떻게 공유하고 차단할 것인지를 결정 하는 레벨




# 트랜잭션

트랜잭션의 특성인 ACID(원자성,일관성,격리성,영속성)가 개발자에게 가져다주는 이점을 설명할 때 자주 인용되는 예로서 은행의 송금 과정이 주로 알려져 있다. 화자 또한 해당 과정을 예로서 MySQL의 엔진인 InnoDB 테이블과 MyISAM 테이블의 차이를 트랜잭션 관점에서 정리했다.  

우선 두 엔진의 가장 큰 차이점은 트랜잭션 지원 유무 로서 MyISAM 은 트랜잭션을 지원하지 않는 반면 INNODB는 트랜잭션을 지원하고 있다. 그리고 이러한 차이는 개발시 어떠한 이점이 있는지 알아보자.

- SQL 쿼리 문
    
    ```java
    -- MyISAM 테이블 생성
    CREATE TABLE account_myisam (
        account_id INT NOT NULL,
        owner_name VARCHAR(100),
        balance DECIMAL(10,2),
        PRIMARY KEY(account_id)
    ) ENGINE=MyISAM;
    
    -- InnoDB 테이블 생성
    CREATE TABLE account_innodb (
        account_id INT NOT NULL,
        owner_name VARCHAR(100),
        balance DECIMAL(10,2),
        PRIMARY KEY(account_id)
    ) ENGINE=INNODB;
    
    -- 각 테이블에 데이터 삽입
    INSERT INTO account_myisam(account_id, owner_name, balance) VALUES (1, 'John Doe', 1000.00);
    INSERT INTO account_innodb(account_id, owner_name, balance) VALUES (1, 'John Doe', 1000.00);
    
    -- 자동 커밋 설정
    SET autocommit=ON;
    
    -- 추가 데이터 삽입
    INSERT INTO account_myisam(account_id, owner_name, balance) VALUES (2, 'Jane Smith', 500.00), (3, 'Alice Johnson', 700.00);
    INSERT INTO account_innodb(account_id, owner_name, balance) VALUES (2, 'Jane Smith', 500.00), (3, 'Alice Johnson', 700.00);
    ```
    
- **account_innodb & account_myisam**
    
<img width="716" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5 01 24" src="https://github.com/LearnDevVitality/RealMySQL/assets/80812697/25ed9da7-bdf3-493f-b973-9160f2caa725">

위와 같은 상황에서 이체 상황에서 개발자가 예측하지 못하는 문제가 발생하는 시나리오를 고민해보자

```java
-- MyISAM을 사용하는 계좌 간의 금액 이체 처리
-- Alice Johnson의 계좌에서 $200를 출금
UPDATE account_myisam SET balance = balance - 200 WHERE account_id = 3;

-- 시스템에 오류 발생 (예: 전원 문제, 시스템 다운 등)
-- 이 다음 단계인 입금 처리가 실행되지 않음

-- 복구 후 데이터 확인
SELECT * FROM account_myisam WHERE account_id = 3;
```

위 시나리오에서  Alice Johnson의 계좌에서 $200가 차감되었지만, 해당 금액을 다른 계좌에 입금하는 단계에서 시스템에서 오류가 발생했다. 그렇지만, MyISAM 은 트랜잭션을 지원하지 않기 때문에, 이러한 변경이 자동으로 롤백되지 않는다…! 결과적으로 Alice Johnson의 계좌에서 $200가 차감되고,
데이터 무결성을 지킬 수 없는 문제가 발생됐다.

이제 트랜잭션을 지원하는 InnoDB 에서의 에러 시나리오를 비교해보자!

```java
-- InnoDB를 사용하는 계좌 간의 금액 이체 처리
START TRANSACTION;
-- Alice Johnson의 계좌에서 $200를 출금
UPDATE account_innodb SET balance = balance - 200 WHERE account_id = 3;
-- Jane Smith의 계좌로 $200 입금
UPDATE account_innodb SET balance = balance + 200 WHERE account_id = 2;

-- 시스템에 오류 발생
-- 트랜잭션 롤백을 통해 모든 변경 사항 취소
ROLLBACK;

-- 복구 후 데이터 확인
SELECT * FROM account_innodb WHERE account_id = 3;

```

트랜잭션의 특징 중 하나인 Atomic 으로 인해 All or Nothing 으로 트랜잭션 실행 전으로 ROLLBACK 되고 데이터의 무결성을 보장하게 되었고, 무엇보다 Alice Johnson의 계좌에서 $200를 지킬 수 있다 👍

### 트랜잭션이 없으면 개발 못 하는건가?

물론 그렇지 않다. MyISAM 엔진의 경우 각 단계별로 문제가 발생했을 경우 IF-ELSE 구문을 추가하여 직접 데이터 클렌징 작업을 통해 데이터 정합성을 맞추게 되면 해결에 가까워질 수 있겠지만, 모든 과정에 대해서 IF-ELSE 를 누락하게 된다면? DB 레벨에서 시작된 에러가 걷잡을 수 없이 큰 문제로 확장될 가능성이 높아질 것이다.

```java
## 트랜잭션 사용

try{
  START TRANSACTION;
  INSERT INTO A...;
  INSERT INTO B...;
  COMMIT;
} catch(exception) {
	ROLLBACK;
}

------------------
## 트랜잭션 미사용

INSERT INTO A..;
IF(insert_succeed) {
	INSERT INTO B..;
	 IF(insert_suceed) {
		// 처리 완료
  } ELSE { //문제 발생시
		DELETE 쿼리 실행 
			iF(DELETE 실패시) {
				해결 불가능한 심각한 상황 발생..!
			}
	  }
	} 
}
```

# 주의사항 - Transaction 잘 사용하기

트랜잭션 또한 DBMS의 커넥션과 동일하게 필요한 최소한의 코드에만 적용하는 것이 좋다. 왜 그러한지 설명하기 앞서 본 주제에 앞서, DB 와 연결하기 위한 커넥션과 이를 관리하는 커넥션 풀에 대해서 알아보자. 

<img width="915" alt="스크린샷 2024-05-09 오후 8 07 52" src="https://github.com/LearnDevVitality/RealMySQL/assets/80812697/f8a28079-ca6a-4db3-a0c0-6f33fb4b1485">


Application 에서 DB 를 사용하기 위해서는 연결은 필수일 것이다. 단, 내가 원하는 DB 와 연결이 되어야 문제 없이 수행할 수 있을 것인데, 문제는 매번 연결 단계에서 JDBC Driver 를 직접 로드하고 커넥션 객체를 받아와야 한다는 점에서 순간적으로 100번의 요청이 발생하게 된다면? 커넥션을 연결하는 과정 또한 100번의 요청에 맞게 수행되어야 할 것이고, 이는 매우 비 효울적인 병목현상의 원인으로 자리매김하게 될 것이다. 

그렇다면 이를 처리하기 위해서는 Application 이 처음 올라갈 때 설정한 커넥션들을 **미리 생성하여 Connection Pool** 에 미리 저장시켜 놓고, 요청이 올 때 마다 Connection 객체를 빌려주고 해당 
요청이 완료된다면 Connection 을 Pool 로 반납히켜 pool 에 저장하면 되지 앞서 말한 수동으로 처리해야 하는 문제에 있어 Connection 의 Managing 을 처리할 Pool 을 통해서 효율적으로 처리할 수 있다.

**요지는 클라이언트의 요청이 너무 길어지면 Connection의 반환시간이 길어질 것이고, 이는 또 다른 문제로 확산될 수 있다는 것이다.**

그러므로 **DB 커넥션을 갖고 있는 범위**와 **트랜잭션이 활성화 되어 있는 프로그램의 범위를 최소화** 해야하며 **네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다**. 그렇지 않다면 DBMS 서버가 높은 부하 상태로 빠지거나 문제가 빈번히 발생할 수 있다.

---

# MySQL 엔진의 잠금

MySQL 에서 사용되는 잠금은 크게 스토리지 엔진 레벨, MySQL 엔진 레벨로 나눌 수 있다.

- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미친다.
- 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

### 글로벌 락

- 명령어 : FLUSH TABLES WITH READ LOCK
- 영향을 미치는 범위 : MySQL 서버 전체(MySQL 에서 제공하는 잠금 가운데 가장 범위가 크다)
- 한 세션에서 글로벌 락을 획득시 다른 세션에서 SELECT 제외한 DDL, DML 사용시 글로벌 락이 해제 될 때까지 대기 상태로 남는다.

### **테이블 락**

- 명령어: LOCK TABLES <테이블명> READ/WRITE
- 영향을 미치는 범위: 명시된 테이블(들)
- 특징: 특정 테이블에 대해 읽기 또는 쓰기 잠금을 설정하여, 잠금이 설정된 테이블에 대해 다른 세션에서는 지정된 작업(읽기 또는 쓰기)을 수행할 수 없게 한다. 읽기 잠금은 여러 세션에서 동시에 설정될 수 있지만, 쓰기 잠금은 동시에 한 세션에서만 설정할 수 있다.

### **네임드 락**

- 명령어: GET_LOCK('lock_name', timeout)
- 영향을 미치는 범위: 서버 수준에서 사용자가 지정한 이름의 잠금
- 특징: 사용자가 지정한 이름의 잠금을 생성하여 다른 세션에서는 해당 잠금을 획득할 수 없게 한다. 잠금 획득 실패 시 지정된 타임아웃 시간까지 대기한다. 네임드 락은 데이터베이스나 테이블에 직접적으로 영향을 미치지 않고, 어플리케이션 로직에서 동기화 목적으로 주로 사용된다.

### **메타데이터 락**

- 명령어: 자동 적용, 사용자가 직접 명령어를 사용하지 않음
- 영향을 미치는 범위: 특정 데이터베이스 오브젝트(테이블, 뷰 등)
- 특징: DDL 작업(예: CREATE, DROP, ALTER)을 수행할 때 해당 오브젝트에 자동으로 설정되는 잠금이다. 이 잠금은 오브젝트의 메타데이터가 변경되는 동안 데이터 일관성과 무결성을 보장하기 위해 사용된다. 메타데이터 잠금은 해당 오브젝트에 대한 다른 DDL 작업을 대기 상태로 만들어 충돌을 방지한다.

---

# **InnoDB 스토리지 엔진 잠금**

### **레코드 락**

- 설명: 레코드 락은 특정 데이터베이스 행(record)에 대해 설정되는 잠금이다. 이 잠금은 다른 트랜잭션이 동일한 행에 대해 동시에 수정을 가하는 것을 방지하기 위해 사용된다.
- InnoDB 스토리지 엔진은 레코드 자체가 아닌, 인덱스의 레코드를 잠근다.
- 영향을 미치는 범위: 특정 행
- 특징: 레코드 락은 해당 행에 대해 쓰기 작업을 시도하는 다른 트랜잭션을 대기 상태로 만든다. 다만 읽기 작업은 일관성 있는 읽기(Non-Locking Read)가 가능하다.

### **갭 락**

- 설명: 갭 락은 특정 레코드 사이의 간격(예: 인덱스 레코드 간)에 설정되는 잠금이다. 이는 팬텀 읽기(다른 트랜잭션이 갭에 새로운 레코드를 삽입하는 것)를 방지하기 위해 사용된다.
- 영향을 미치는 범위: 레코드 간의 간격
- 특징: 갭 락은 주로 격리 수준이 높은 트랜잭션에서 발생하며, 갭에 새로운 레코드의 삽입을 방지해 다른 트랜잭션이 이 갭을 보지 못하게 한다.

### **넥스트 키 락**

- 설명: 넥스트 키 락은 레코드 락과 갭 락을 합친 형태로, 레코드 자체와 그 레코드 앞의 갭을 모두 잠그는 것이다.
- 영향을 미치는 범위: 특정 레코드와 그 앞의 갭
- 특징: 이는 동시성을 제한하지만 데이터의 일관성을 보장하기 위해 사용된다. 넥스트 키 락은 반복 가능한 읽기(isolation level)에서 팬텀 읽기를 방지한다.

### **자동 증가 락**

- 설명: 자동 증가 락은 AUTO_INCREMENT 속성이 있는 열에 대한 삽입을 동기화하기 위해 사용된다.
- 영향을 미치는 범위: AUTO_INCREMENT 속성을 가진 열
- 특징: 이 잠금은 삽입 작업 동안만 유지되며, 여러 트랜잭션이 동시에 같은 테이블에 삽입을 시도할 때 충돌을 방지한다.

### **인덱스와 잠금**

- 설명: 인덱스를 통한 데이터 액세스에서 InnoDB는 인덱스 레코드에 락을 설정할 수 있다.
- 영향을 미치는 범위: 인덱스 레코드
- 특징: 인덱스 잠금을 통해 데이터의 정확성과 일관성을 유지할 수 있으며, 특정 인덱스에 대한 동시 수정을 방지한다. 적절한 인덱스가 준비되어 있지 않는다면, 각 클라이언트 간의 동시성이 상당히 떨어져서 한 세션에서 작업을 하는 중에는 다른 클라이언트는 해당 테이블을 작업하지 못하고 기다려야 하는 상황이 발생할 수 있다.
- 인덱스가 없는 테이블의 레코드에 락을 걸게 된다면 InnoDB는 테이블을 Full Scan 하면서 작업하게 되고 이러한 과정에서 작업이 진행되는 모든 레코드를 잠그게 된다. 이러한 특징은 성능 저하 원인으로 잡힐 수도 있으므로 이는 인덱스의 설계에 대한 중요성을 보여준다.

### **레코드 수준의 잠금 확인 및 해제**

- 설명: InnoDB에서는 레코드 수준의 잠금을 확인하고 해제할 수 있는 기능을 제공한다.
- 영향을 미치는 범위: 특정 레코드
- 특징: 현재 활성화된 잠금과 해당 잠금을 보유한 트랜잭션을 확인할 수 있다. 잠금 해제는 트랜잭션이 커밋되거나 롤백될 때 자동으로 수행된다.

---

# MySQL의 격리 수준

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 설명 |
| --- | --- | --- | --- | --- |
| Read UNCOMMITTED | 가능 | 가능 | 가능 | 가장 낮은 격리 수준으로, 다른 트랜잭션에서 커밋하지 않은 데이터를 읽을 수 있다. 이로 인해 "Dirty Read"가 발생할 수 있다. |
| READ COMMITTED | 불가능 | 가능 | 가능 | 다른 트랜잭션이 커밋한 데이터만 읽을 수 있으며, 이로 인해 Dirty Read는 방지되지만 Non-Repeatable Read가 발생될 수 있다. |
| REPEATABLE READ | 불가능 | 불가능 | 가능 | MySQL의 기본 격리 수준으로, 트랜잭션 시작 시점의 데이터 상태를 유지 이로 인해 같은 트랜잭션 내에서 같은 쿼리를 반복 실행해도 동일한 결과가 보장 |
| SERIALIZABLE | 불가능 | 불가능 | 불가능 | 가장 높은 격리 수준으로, 모든 트랜잭션이 순차적으로 실행되는 것처럼 처리된다. 이로 인해 모든 종류의 읽기 이상 현상이 방지되지만, 동시성이 처리 수준이 크게 감소되는 문제점 존재 |

- **Dirty READ**
    
    > Dirty Read는 한 트랜잭션이 다른 트랜잭션에 의해 아직 커밋되지 않은 데이터를 읽을 수 있을 때 발생하는 동시성 문제
    > 
    
     데이터의 일관성과 무결성에 문제를 일으킬 수 있으며, 이후 해당 데이터를 수정하거나 커밋을 하지 않고 롤백하는 트랜잭션이 있을 경우, 읽은 데이터가 무효가 되어 심각한 오류를 초래할 수 있다.
    
- **Phantom Read**
    
    > Phantom Read는 한 트랜잭션 내에서 동일한 쿼리를 여러 번 실행했을 때, 처음의 쿼리 실행 결과와 나중의 실행 결과가 다른 행을 포함하는 경우 발생하는 동시성 문제
    > 
    
    이는 다른 트랜잭션이 쿼리가 실행되는 동안 새로운 행을 삽입하거나 삭제할 때 발생할 수 있다. 이 현상은 트랜잭션이 두 번째 쿼리 실행 사이에 발생하는 데이터베이스의 변화를 "read” 하는 것
    
- **Non-Repeatable Read**
    
    > 한 트랜잭션이 동일한 쿼리를 두 번 실행할 때, 두 쿼리 결과가 서로 다른 데이터를 반환하는 경우 발생하는 동시성 문제
    > 
    
    이는 다른 트랜잭션이 첫 번째와 두 번째 쿼리 실행 사이에 해당 데이터를 수정하거나 업데이트할 때 발생하며  트랜잭션은 처음 읽은 데이터와 두 번째로 읽은 데이터 사이에 일관성이 없게 된다.
    

## **Phantom Read & Non-Repeatable Read 차이는?**

Non-Repeatable Read 예)

- 한 사용자가 동일한 계정의 잔고를 두 번 확인했을 때, 첫 번째 조회에서는 100달러였지만, 다른 사용자가 거래를 처리하는 사이에 50달러가 추가되어 두 번째 조회에서 150달러로 조회되는 경우

Phantom Read 예)
• 한 사용자가 특정 조건을 만족하는 주문 목록을 조회했을 때 처음에는 10개의 주문이 조회되었지만, 다른 사용자가 새로운 주문을 추가하면서 같은 쿼리를 다시 실행했을 때 11개의 주문이 조회되는 경우

차이점 : 

- **Non-Repeatable Read**는 동일한 데이터 레코드에 대한 조회 결과가 두 번의 조회 사이에 데이터가 변경되어 일관성이 없는 것
- **Phantom Read**는 쿼리 결과로 반환되는 데이터 행 자체의 수나 내용이 변경되는 것  다시말해, 쿼리 결과에 포함되는 데이터 행의 집합이 변하는 것
